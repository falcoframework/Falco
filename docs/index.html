<!DOCTYPE html>
<html lang="en">

<!-- /head --> 
<head>
<meta charset="utf-8">
<meta content="width=device-width,initial-scale=1" name="viewport">
<meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
<title>Falco Framework - F# web toolkit for ASP.NET Core</title> 
<meta name="description" content="A functional-first toolkit for building brilliant ASP.NET Core applications using F#.">

<!-- /head/style -->
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="preconnect" href="https://fonts.gstatic.com">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
<link href="/prism.css" rel="stylesheet" />
<link href="/tachyons.css" rel="stylesheet" />
<style>
:root {
  --gray: rgba(51,51,51,.6);
  --silver: rgb(204, 204, 204);
  --slate: rgb(51, 51, 51);
  --merlot: rgb(50, 1, 79);
  --purple: rgb(184, 69, 252);
  --washed-purple: rgba(185, 69, 252, 0.10);
}

/* sizing */
.mw9 { max-width: 80rem; }

/* font */
.noto { font-family: 'Noto Sans JP', sans-serif; }
.noto-serif { font-family: 'Noto Serif JP', Georgia, serif; }

/* bg */
.bg-merlot { background-color: var(--merlot); }
.bg-dots { background-image: radial-gradient(rgba(255,255,255,.3) 1px, transparent 1px), radial-gradient(rgba(255,255,255,.3) 1px, transparent 1px); background-size: 75px 75px; background-position: 0px 0px,40px 25px; }
.bg-parallax {  background-attachment: fixed; }

/* color */
.merlot { color: var(--merlot); }

/* opacity */
.hover-o-100:hover { opacity: 1; }

/* transform */
.ty--50 { transform: translateY(-50%);}

/* text */
main h1, main h2, main h3, main h4, main h5 { margin-bottom: 0; font-weight: 400; }
main h2 { margin-top: 3rem; font-size: 2em; color: var(--gray); }
main h3 { margin-top: 2rem; font-size: 1.5em; }
main h2 + h3 { margin-top: .5rem; } 
main p { line-height: 1.4; }

a { color: inherit; transition: color .125s ease-in; }
main a:visited { color: inherit; }
main a:hover { color: var(--purple); }

blockquote { margin-left: 0; margin-right: 0; padding: 1rem; border-left: 4px solid var(--purple); background: var(--washed-purple); }
blockquote p { margin: 0; }

/* tables */
table { text-align: left; border-collapse: collapse; }
td, th { padding: .5rem; border-bottom: 1px solid var(--silver); }

/* code */
code[class*="language-"], pre[class*="language-"] { font-size: .875rem; }
pre[class*="language-"] { padding: 1rem; }
pre { overflow-x: auto; overflow-wrap: normal; white-space: pre; font-size: .875rem; margin: 1rem 0; padding: 1rem; color: #eff0f9; background: #333; }
code { vertical-align: middle; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; background-color: var(--washed-purple); }
pre > code { background-color: inherit; }
h2 > code, h3 > code, p > code { padding: 0 .25rem; }

@media screen and (min-width: 640px) {      
  main { font-size: 1.125em; }  
  code[class*="language-"], pre[class*="language-"] { font-size: 1rem; }
} 

</style>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-D62HSJHMNZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-D62HSJHMNZ');
</script>
</head>

<!-- /body -->
<body class="noto bg-merlot bg-dots bg-parallax">

<!-- /body/header -->
<header class="pv3">
  <div class="mw9 center pa3">
    <!-- /top bar -->
    <div class="pb3">
      <nav class="flex flex-column flex-row-l items-center">
        <a href="/"><img src="/icon.svg" class="w3 pb3 pb0-l o-80 hover-o-100" /></a>
        <div class="flex-grow-1-l tc tr-l">
          <a href="#key-features" title="Overview of Falco's key features" class="dib mh2 mh3-l no-underline white-90 hover-white">overview</a>
          <a href="https://www.pimbrouwers.com/2020/12/08/fsharp-on-the-web-a-guide-to-building-websites-with-falco-dotnet-x-and-aspdotnet-core.html" target="_blank" title="A guide on how to write full production-ready applications using Falco" class="dib mh2 mh3-l no-underline white-90 hover-white">guide</a>
          <a href="https://github.com/pimbrouwers/Falco" 
             target="_blank" 
             alt="Falco GitHub Link" 
             title="Fork Falco on GitHub"
             class="dib ml2 ml3-l no-underline white-90 hover-white">code</a>
        </div>
      </nav>
    </div>
    <!-- hello -->
<div class="mw6 center pb5 noto tc fw4 lh-copy white">
    <h1 class="mb3 fw4 f2">Meet Falco.</h1>
    <h2 class="mt0 mb4 fw4 f4 f3-l">Falco is a toolkit for building secure, fast, functional-first and fault-tolerant web applications using F#.</h2>

    <div class="tc">
      <a href="#getting-started" target="_blank" title="Learn how to get started using Falco" class="dib mh2 mb2 ph3 pv2 merlot bg-white ba b--white br2 no-underline">Get Started</a>
      <a href="#falco" target="_blank" class="dib mh2 ph3 pv2 white ba b--white br2 no-underline">Learn More</a>
    </div>
</div>

<!-- release info -->
<div class="mb4 bt b--white-20 tc lh-solid">
    <a href="https://www.nuget.org/packages/Falco" class="dib center ph1 ph4-l pv3 bg-merlot white no-underline ty--50" target="_blank">Latest release: 3.1.5 (September 24, 2021)</a>
</div>

<!-- benefits -->
<div class="cf tc lh-copy">    
    <div class="fl-l mw5 mw-none-l w-25-l center mb4 ph4-l br-l b--white-20">
        <img src="/icons/fast.svg" class="w4 o-90" />
        <h3 class="mv2 white">Blazing Fast</h3>
        <div class="mb3 white-90">Built on the high-performance primitives of ASP.NET.</div>
        <a href="https://web-frameworks-benchmark.netlify.app/result?l=fsharp" target="_blank" class="dib mh2 pa2 f6 white ba b--white br2 no-underline">Learn More</a>
    </div>    
    
    <div class="fl-l mw5 mw-none-l w-25-l center mb4 ph4-l br-l b--white-20">
        <img src="/icons/easy.svg" class="w4 o-90" />
        <h3 class="mv2 white">Easy to Learn</h3>
        <div class="mb3 white-90">Designed for getting up to speed quickly.</div>
        <a href="#getting-started" title="Learn how to get started using Falco" class="dib mh2 pa2 f6 white ba b--white br2 no-underline">Get Started</a>
    </div>    

    <div class="fl-l mw5 mw-none-l w-25-l center mb4 ph4-l br-l b--white-20">
        <img src="/icons/view.svg" class="w4 o-90" />
        <h3 class="mv2 white">Native View Engine</h3>
        <div class="mb3 white-90">Markup is written in F# and compiled.</div>
        <a href="#markup" title="View examples of Falco markup module" class="dib mh2 pa2 f6 white ba b--white br2 no-underline">See Examples</a>
    </div>    

    <div class="fl-l mw5 mw-none-l w-25-l center mb4 ph4-l">
        <img src="/icons/integrate.svg" class="w4 o-90" />
        <h3 class="mv2 white">Extensible</h3>
        <div class="mb3 white-90">Seamlessly integrates with existing libraries.</div>
        <a href="https://github.com/pimbrouwers/Falco/tree/master/samples/ScribanExample" target="_blank" title="Example of incorporating a third-party view engine" class="dib mh2 pa2 f6 white ba b--white br2 no-underline">Explore How</a>
    </div>    
</div>
   
  </div>
</header>
  
<!-- /body/content -->
<div class="bg-white">
  <div class="cf mw8 center pv4 pv5-l ph3">
    <main><h1 id="falco">Falco</h1>
<p><a href="https://www.nuget.org/packages/Falco"><img src="https://img.shields.io/nuget/v/Falco.svg" alt="NuGet Version" /></a>
<a href="https://travis-ci.org/pimbrouwers/Falco"><img src="https://travis-ci.org/pimbrouwers/Falco.svg?branch=master" alt="Build Status" /></a></p>
<pre><code class="language-fsharp">open Falco
open Falco.Routing
open Falco.HostBuilder

webHost [||] {
    endpoints [                    
        get &quot;/&quot; (Response.ofPlainText &quot;Hello World&quot;)
    ]
}
</code></pre>
<p><a href="https://github.com/pimbrouwers/Falco">Falco</a> is a toolkit for building fast, functional-first and fault-tolerant web applications using F#.</p>
<ul>
<li>Built upon the high-performance primitives of ASP.NET Core.</li>
<li>Optimized for building HTTP applications quickly.</li>
<li>Seamlessly integrates with existing .NET Core middleware and frameworks.</li>
</ul>
<h2 id="key-features">Key Features</h2>
<ul>
<li>Asynchronous <a href="#request-handling">request handling</a>.</li>
<li>Simple and powerful <a href="#routing">routing</a> API.</li>
<li>Fast, secure and configurable <a href="#host-builder">web server</a>.</li>
<li>Native F# <a href="#markup">view engine</a>.</li>
<li>Uniform API for <a href="#model-binding">model binding</a>.</li>
<li><a href="#authentication">Authentication</a> and <a href="#security">security</a> utilities.</li>
<li>Built-in support for <a href="#handling-large-uploads">large uploads</a>.</li>
</ul>
<h2 id="design-goals">Design Goals</h2>
<ul>
<li>Aim to be very small and easily learnable.</li>
<li>Should be extensible.</li>
<li>Should provide a toolset to build a working end-to-end web application.</li>
</ul>
<h2 id="table-of-contents">Table of Contents</h2>
<ol>
<li><a href="#getting-started">Getting Started</a></li>
<li><a href="#sample-applications">Sample Applications</a></li>
<li><a href="#request-handling">Request Handling</a></li>
<li><a href="#routing">Routing</a></li>
<li><a href="#model-binding">Model Binding</a></li>
<li><a href="#json">JSON</a></li>
<li><a href="#markup">Markup</a></li>
<li><a href="#host-builder">Host Builder</a></li>
<li><a href="#authentication">Authentication</a></li>
<li><a href="#security">Security</a></li>
<li><a href="#why-falco">Why &quot;Falco&quot;?</a></li>
<li><a href="#find-a-bug">Find a bug?</a></li>
<li><a href="#license">License</a></li>
</ol>
<h2 id="getting-started">Getting Started</h2>
<h3 id="using-dotnet-new">Using <code>dotnet new</code></h3>
<p>The easiest way to get started with Falco is by installing the <code>Falco.Template</code> package, which adds a new template to your <code>dotnet new</code> command line tool:</p>
<pre><code class="language-cmd">dotnet new -i &quot;Falco.Template::*&quot;
</code></pre>
<p>Afterwards you can create a new Falco application by running:</p>
<pre><code class="language-cmd">dotnet new falco -o HelloWorldApp
</code></pre>
<h3 id="manually-installing">Manually installing</h3>
<p>Create a new F# web project:</p>
<pre><code class="language-cmd">dotnet new web -lang F# -o HelloWorldApp
</code></pre>
<p>Install the nuget package:</p>
<pre><code class="language-cmd">dotnet add package Falco
</code></pre>
<p>Remove the <code>Startup.fs</code> file and save the following in <code>Program.fs</code> (if following the manual install path):</p>
<pre><code class="language-fsharp">module HelloWorld.Program

open Falco
open Falco.Routing
open Falco.HostBuilder

[&lt;EntryPoint&gt;]
let main args =
    webHost args {
        endpoints [ 
            get &quot;/&quot; (Response.ofPlainText &quot;Hello World&quot;)
        ]
    }
    0
</code></pre>
<p>Run the application:</p>
<pre><code class="language-cmd">dotnet run
</code></pre>
<p>There you have it, an industrial-strength <a href="https://github.com/pimbrouwers/Falco/tree/master/samples/HelloWorld">Hello World</a> web app, achieved using only base ASP.NET Core libraries. Pretty sweet!</p>
<h2 id="sample-applications">Sample Applications</h2>
<p>Code is always worth a thousand words, so for the most up-to-date usage, the <a href="https://github.com/pimbrouwers/Falco/tree/master/samples">/samples</a> directory contains a few sample applications.</p>
<table>
<thead>
<tr>
<th>Sample</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/pimbrouwers/Falco/tree/master/samples/HelloWorld">Hello World</a></td>
<td>A basic hello world app</td>
</tr>
<tr>
<td><a href="https://github.com/pimbrouwers/Falco/tree/master/samples/ConfigureHost">Configure Host</a></td>
<td>Demonstrating how to configure the <code>IHost</code> instance using the <code>webHost</code> computation expression</td>
</tr>
<tr>
<td><a href="https://github.com/pimbrouwers/Falco/tree/master/samples/Blog">Blog</a></td>
<td>A basic markdown (with YAML frontmatter) blog</td>
</tr>
<tr>
<td><a href="https://github.com/pimbrouwers/Falco/tree/master/samples/ScribanExample">Third-part View Engine</a></td>
<td>Demonstrating how to render with an external view engine, specifically <a href="https://github.com/scriban/scriban">Scriban</a></td>
</tr>
<tr>
<td><a href="https://github.com/pimbrouwers/FalcoJournal">Falco Journal</a></td>
<td>A bullet journal built using Falco</td>
</tr>
</tbody>
</table>
<h2 id="request-handling">Request Handling</h2>
<p>The <code>HttpHandler</code> type is used to represent the processing of a request. It can be thought of as the eventual (i.e. asynchronous) completion and processing of an HTTP request, defined in F# as: <code>HttpContext -&gt; Task</code>. Handlers will typically involve some combination of: route inspection, form/query binding, business logic and finally response writing.  With access to the <code>HttpContext</code> you are able to inspect all components of the request, and manipulate the response in any way you choose.</p>
<p>Basic request/response handling is divided between the aptly named <a href="https://github.com/pimbrouwers/Falco/tree/master/src/Request.fs"><code>Request</code></a> and <a href="https://github.com/pimbrouwers/Falco/tree/master/src/Response.fs"><code>Response</code></a> modules, which offer a suite of continuation-passing style (CPS) <code>HttpHandler</code> functions for common scenarios.</p>
<h3 id="plain-text-responses">Plain Text responses</h3>
<pre><code class="language-fsharp">let textHandler : HttpHandler =
    Response.ofPlainText &quot;hello world&quot;
</code></pre>
<h3 id="html-responses">HTML responses</h3>
<pre><code class="language-fsharp">let htmlHandler : HttpHandler =
    let doc =
        Elem.html [ Attr.lang &quot;en&quot; ] [
            Elem.head [] []
            Elem.body [] [
                Elem.h1 [] [ Text.raw &quot;Sample App&quot; ]                
            ]
        ]

    doc
    |&gt; Response.ofHtml
</code></pre>
<p>Alternatively, if you're using an external view engine and want to return an HTML response from a string literal, then you can use <code>Response.ofHtmlString</code>.</p>
<pre><code class="language-fsharp">let htmlHandler : HttpHandler = 
    let html = &quot;&lt;html&gt;...&lt;/html&gt;&quot;

    html
    |&gt; Response.ofHtmlString
</code></pre>
<h3 id="json-responses">JSON responses</h3>
<blockquote>
<p>IMPORTANT: This handler uses the default <code>System.Text.Json.JsonSerializer</code>. See <a href="#json">JSON</a> section below for further information.</p>
</blockquote>
<pre><code class="language-fsharp">type Person =
    { First : string
      Last  : string }

let jsonHandler : HttpHandler =
    { First = &quot;John&quot;; Last = &quot;Doe&quot; }
    |&gt; Response.ofJson
</code></pre>
<h3 id="redirect-301302-response">Redirect (301/302) Response</h3>
<pre><code class="language-fsharp">let oldUrlHandler : HttpHandler =
    Response.redirect &quot;/new-url&quot; true
</code></pre>
<blockquote>
<p>Note: The trailing <code>bool</code> value is used to indicate permanency (i.e., true = 301 / false = 302)</p>
</blockquote>
<h2 id="accessing-request-data">Accessing Request Data</h2>
<p>Falco exposes a <a href="#model-binding">uniform API</a> to obtain typed values from the various sources of request data. Note, the similarity in the various binders below.</p>
<h3 id="route-collection">Route Collection</h3>
<pre><code class="language-fsharp">let helloHandler : HttpHandler =
    let routeBinder (route : RouteCollectionReader) =
        let name = route.GetString &quot;name&quot; &quot;World&quot; 
        sprintf &quot;Hello %s&quot; name
        
    Request.mapRoute routeBinder Response.ofPlainText
</code></pre>
<h3 id="query-parameters">Query Parameters</h3>
<pre><code class="language-fsharp">let helloHandler : HttpHandler =
    let queryBinder (query : QueryCollectionReader) =
        let name = query.GetString &quot;name&quot; &quot;World&quot; 
        sprintf &quot;Hello %s&quot; name
        
    Request.mapQuery queryBinder Response.ofPlainText
</code></pre>
<h3 id="form-data">Form Data</h3>
<pre><code class="language-fsharp">let helloHandler : HttpHandler =
    let formBinder (query : FormCollectionReader) =
        let name = query.GetString &quot;name&quot; &quot;World&quot; 
        sprintf &quot;Hello %s&quot; name
        
    Request.mapForm formBinder Response.ofPlainText
</code></pre>
<p>To prevent XSS attacks it is often advisable to use a <a href="#security">CSRF token</a> during form submissions. In these situations, you'll want to validate the token before processing the form input using the <code>Request.mapFormSecure</code> (or <code>Request.bindFormSecure</code>). These functions will automatically validate the token for you before consuming input.</p>
<pre><code class="language-fsharp">let secureHelloHandler : HttpHandler =
    let formBinder (query : FormCollectionReader) =
        let name = query.GetString &quot;name&quot; &quot;World&quot; 
        sprintf &quot;Hello %s&quot; name

    let invalidTokenHandler : HttpHandler =
        Response.withStatusCode 403
        &gt;&gt; Response.ofEmpty
        
    Request.mapFormSecure formBinder Response.ofPlainText invalidTokenHandler
</code></pre>
<h2 id="response-modifiers">Response Modifiers</h2>
<p>Response modifiers can be thought of as the in-and-out modification of the <code>HttpResponse</code>. A preamble to writing and returning. Since these functions receive the <code>Httpcontext</code> as input and return it as the only output, they can take advantage of <a href="22">function compoistion</a>.</p>
<h3 id="set-the-status-code-of-the-response">Set the status code of the response</h3>
<pre><code class="language-fsharp">let notFoundHandler : HttpHandler =
    Response.withStatusCode 404
    &gt;&gt; Response.ofPlainText &quot;Not found&quot;
</code></pre>
<h3 id="add-a-header-to-the-response">Add a header to the response</h3>
<pre><code class="language-fsharp">let handlerWithHeader : HttpHandler =
    Response.withHeader &quot;Content-Language&quot; &quot;en-us&quot;
    &gt;&gt; Response.ofPlainText &quot;Hello world&quot;
</code></pre>
<h3 id="add-a-cookie-to-the-response">Add a cookie to the response</h3>
<pre><code class="language-fsharp">let handlerWithHeader : HttpHandler =
    Response.withCookie &quot;greeted&quot; &quot;1&quot;
    &gt;&gt; Response.ofPlainText &quot;Hello world&quot;
</code></pre>
<blockquote>
<p>IMPORTANT: <em>Do not</em> use this for authentication. Instead use the <code>Auth.signIn</code> and <code>Auth.signOut</code> functions found in the <a href="#authentication">Authentication</a> module.</p>
</blockquote>
<h2 id="routing">Routing</h2>
<p>The breakdown of <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-3.1#configuring-endpoint-metadata" title="EndpointRouting in ASP.NET Core">Endpoint Routing</a> is simple. Associate a specific <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-3.1#route-template-reference">route pattern</a> (and optionally an HTTP verb) to an <code>HttpHandler</code> which represents the ongoing processing (and eventual return) of a request.</p>
<p>Bearing this in mind, routing can practically be represented by a list of these &quot;mappings&quot; known in Falco as an <code>HttpEndpoint</code> which bind together: a route, verb and handler.</p>
<pre><code class="language-fsharp">let helloHandler : HttpHandler =
    let getMessage (route : RouteCollectionReader) =
        route.GetString &quot;name&quot; &quot;World&quot; 
        |&gt; sprintf &quot;Hello %s&quot;
        
    Request.mapRoute getMessage Response.ofPlainText

let loginHandler : HttpHandler = // ...

let loginSubmitHandler : HttpHandler = // ...  

let endpoints : HttpEndpoint list =
  [
    // a basic GET handler
    get &quot;/hello/{name:alpha}&quot; helloHandler

    // multi-method endpoint
    all &quot;/login&quot;
        [
            POST, loginSubmitHandler
            GET,  loginHandler
        ]
  ]
</code></pre>
<h2 id="model-binding">Model Binding</h2>
<p>Reflection-based approaches to binding at IO boundaries work well for simple use cases. But as the complexity of the input rises it becomes error-prone and often involves tedious workarounds. This is especially true for an expressive, algebraic type system like F#. As such, it is often advisable to take back control of this process from the runtime. An added bonus of doing this is that it all but eliminates the need for <code>[&lt;CLIMutable&gt;]</code> attributes.</p>
<p>We can make this simpler by creating a succinct API to obtain typed values from <code>IFormCollection</code>, <code>IQueryCollection</code>, <code>RouteValueDictionary</code> and <code>IHeaderCollection</code>. <em>Readers</em> for all four exist as derivatives of <code>StringCollectionReader</code> which is an abstraction intended to make it easier to work with the string-based key/value collections.</p>
<p>The built-in model binding handlers come in two flavors, both of which are continuation-style handlers:</p>
<ol>
<li><p><code>Request.mapXXX</code></p>
<ul>
<li>Signature: <code>(map: XXXCollectionReader -&gt; 'a) (next : 'a -&gt; HttpHandler) -&gt; HttpHandler</code></li>
<li>The &quot;map&quot; family of handlers are more commonly used and assume that binding will always succeed in one manner or another, either via default values or <code>Option&lt;T&gt;</code>.</li>
</ul>
</li>
<li><p><code>Request.bindXXX</code></p>
<ul>
<li>Signature: <code>(bind: XXXCollectionReader -&gt; Result&lt;'a, 'b&gt;) (handleOk : 'a -&gt; HttpHandler) -&gt; (handleError : 'b -&gt; HttpHandler) -&gt; HttpHandler</code></li>
<li>The &quot;bind&quot; family of handlers are useful when you explicitly want to indicate errors during binding and return a different response when they occur.</li>
</ul>
</li>
</ol>
<h3 id="route-binding">Route Binding</h3>
<pre><code class="language-fsharp">let mapRouteHandler : HttpHandler =
    let routeMap (r : RouteCollectionReader) = 
        r.GetString &quot;Name&quot; &quot;John Doe&quot;
    
    Request.mapRoute routeMap Response.ofJson

let bindRouteHandler : HttpHandler = 
    let routeBind (r : RouteCollectionReader) =
        match r.TryGetString &quot;Name&quot; with
        | Some name -&gt; Ok name
        | _         -&gt; Error {| Message = &quot;Invalid route&quot; |}
    
    let handleOk = Response.ofJson
    let handleError = Response.ofJson

    Request.bindRoute routeBind handleOk handleError

let manualRouteHandler : HttpHandler =
    fun ctx -&gt;
        let r : RouteCollectionReader = Request.getRoute ctx
        let name = r.GetString &quot;Name&quot; &quot;John Doe&quot;  

        Response.ofJson name ctx
</code></pre>
<h3 id="query-binding">Query Binding</h3>
<pre><code class="language-fsharp">type Person = { FirstName : string; LastName : string }

let mapQueryHandler : HttpHandler =    
    let queryMap (q : QueryCollectionReader) =
        let first = q.GetString &quot;FirstName&quot; &quot;John&quot; // Get value or return default value
        let last = q.GetString &quot;LastName&quot; &quot;Doe&quot;
        { FirstName = first; LastName = last }

    Request.mapQuery queryMap Response.ofJson 

let bindQueryHandler : HttpHandler = 
    let queryBind (q : QueryCollectionReader) =
        match q.TryGetString &quot;FirstName&quot;, q.TryGetString &quot;LastName&quot; with
        | Some f, Some l -&gt; Ok { FirstName = f; LastName = l }
        | _  -&gt; Error {| Message = &quot;Invalid query string&quot; |}

    let handleOk = Response.ofJson
    let handleError = Response.ofJson

    Request.bindQuery queryBind handleOk handleError 

let manualQueryHandler : HttpHandler =
    fun ctx -&gt;
        let q : QueryCollectionReader = Request.getQuery ctx
        
        let person = 
            { FirstName = q.GetString &quot;FirstName&quot; &quot;John&quot; // Get value or return default value
              LastName  = q.GetString &quot;LastName&quot; &quot;Doe&quot; }

        Response.ofJson person ctx
</code></pre>
<h3 id="form-binding">Form Binding</h3>
<p>The <code>FormCollectionReader</code> has full access to the <code>IFormFilesCollection</code> via the <code>_.Files</code> member.</p>
<blockquote>
<p>Note the addition of <code>Request.mapFormSecure</code> and <code>Request.bindFormSecure</code> which will automatically validate CSRF tokens for you.</p>
</blockquote>
<pre><code class="language-fsharp">type Person = { FirstName : string; LastName : string }

let mapFormHandler : HttpHandler =   
    let formMap (f : FormCollectionReader) =
        let first = f.GetString &quot;FirstName&quot; &quot;John&quot; // Get value or return default value
        let last = f.GetString &quot;LastName&quot; &quot;Doe&quot;        
        { FirstName = first; LastName = last }

    Request.mapForm formMap Response.ofJson 

let mapFormSecureHandler : HttpHandler =    
    let formMap (f : FormCollectionReader) =
        let first = f.GetString &quot;FirstName&quot; &quot;John&quot; // Get value or return default value
        let last = f.GetString &quot;LastName&quot; &quot;Doe&quot;        
        { FirstName = first; LastName = last }

    let handleInvalidCsrf : HttpHandler = 
        Response.withStatusCode 400 &gt;&gt; Response.ofEmpty

    Request.mapFormSecure formMap Response.ofJson handleInvalidCsrf

let bindFormHandler : HttpHandler = 
    let formBind (f : FormCollectionReader) =
        match f.TryGetString &quot;FirstName&quot;, f.TryGetString &quot;LastName&quot; with
        | Some f, Some l -&gt; Ok { FirstName = f; LastName = l }
        | _  -&gt; Error {| Message = &quot;Invalid form data&quot; |}

    let handleOk = Response.ofJson
    let handleError = Response.ofJson

    Request.bindForm formBind handleOk handleError 

let bindFormSecureHandler : HttpHandler = 
    let formBind (f : FormCollectionReader) =
        match f.TryGetString &quot;FirstName&quot;, f.TryGetString &quot;LastName&quot; with
        | Some f, Some l -&gt; Ok { FirstName = f; LastName = l }
        | _  -&gt; Error {| Message = &quot;Invalid form data&quot; |}

    let handleOk = Response.ofJson
    let handleError = Response.ofJson
    let handleInvalidCsrf : HttpHandler = 
        Response.withStatusCode 400 &gt;&gt; Response.ofEmpty

    Request.bindFormSecure formBind handleOk handleError handleInvalidCsrf

let manualFormHandler : HttpHandler =
    fun ctx -&gt; task {
        let! f : FormCollectionReader = Request.getForm ctx
        
        let person = 
            { FirstName = f.GetString &quot;FirstName&quot; &quot;John&quot; // Get value or return default value
              LastName = f.GetString &quot;LastName&quot; &quot;Doe&quot; }

        return! Response.ofJson person ctx
    }        
</code></pre>
<h4 id="multipartform-data-binding"><code>multipart/form-data</code> Binding</h4>
<p>Microsoft defines <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/models/file-uploads?view=aspnetcore-3.1#upload-large-files-with-streaming" title="Large file uploads">large uploads</a> as anything <strong>&gt; 64KB</strong>, which well... is most uploads. Anything beyond this size and they recommend streaming the multipart data to avoid excess memory consumption.</p>
<p>To make this process <strong>a lot</strong> easier Falco provides a set of four <code>HttpHandler</code>'s analogous to the form handlers above, which utilize an <code>HttpContext</code> extension method called <code>TryStreamFormAsync()</code> that will attempt to stream multipart form data, or return an error message indicating the likely problem.</p>
<p>Below is an example demonstrating the insecure map variant:</p>
<pre><code class="language-fsharp">let imageUploadHandler : HttpHandler =
    let formBinder (f : FormCollectionReader) : IFormFile option =
        f.TryGetFormFile &quot;profile_image&quot;
    
    let uploadImage (profileImage : IFormFile option) : HttpHandler = 
        // Process the uploaded file ...

    // Safely buffer the multipart form submission
    Request.mapFormStream formBinder uploadImage
</code></pre>
<h2 id="json">JSON</h2>
<p>Included in Falco are basic JSON in/out handlers, <code>Request.bindJson</code> and <code>Response.ofJson</code> respectively. Both rely on <code>System.Text.Json</code> and thus have minimal support for F#'s algebraic types.</p>
<pre><code class="language-fsharp">type Person = { FirstName : string; LastName : string }

let jsonHandler : HttpHandler =
    { FirstName = &quot;John&quot;; LastName = &quot;Doe&quot; }
    |&gt; Response.ofJson

let jsonBindHandler : HttpHandler =    
    let handleOk person : HttpHandler = 
        let message = sprintf &quot;hello %s %s&quot; person.First person.Last
        Response.ofPlainText message

    let handleError error : HttpHandler = 
        let message = sprintf &quot;Invalid JSON: %s&quot; error
        Response.withStatusCode 400 &gt;&gt; Response.ofPlainText message

    Request.bindJson handleOk handleError
</code></pre>
<h2 id="markup">Markup</h2>
<p>A core feature of Falco is the XML markup module. It can be used to produce any form of angle-bracket markup (i.e. HTML, SVG, XML etc.).</p>
<p>For example, the module is easily extended since creating new tags is simple. An example to render <code>&lt;svg&gt;</code>'s:</p>
<pre><code class="language-fsharp">let svg (width : float) (height : float) =
    Elem.tag &quot;svg&quot; [
        Attr.create &quot;version&quot; &quot;1.0&quot;
        Attr.create &quot;xmlns&quot; &quot;http://www.w3.org/2000/svg&quot;
        Attr.create &quot;viewBox&quot; (sprintf &quot;0 0 %f %f&quot; width height)
    ]

let path d = Elem.tag &quot;path&quot; [ Attr.create &quot;d&quot; d ] []

let bars =
    svg 384.0 384.0 [
        path &quot;M368 154.668H16c-8.832 0-16-7.168-16-16s7.168-16 16-16h352c8.832 0 16 7.168 16 16s-7.168 16-16 16zm0 0M368 32H16C7.168 32 0 24.832 0 16S7.168 0 16 0h352c8.832 0 16 7.168 16 16s-7.168 16-16 16zm0 0M368 277.332H16c-8.832 0-16-7.168-16-16s7.168-16 16-16h352c8.832 0 16 7.168 16 16s-7.168 16-16 16zm0 0&quot;
    ]
</code></pre>
<h3 id="html-view-engine">HTML View Engine</h3>
<p>Most of the standard HTML tags &amp; attributes have been built into the markup module and produce objects to represent the HTML node. Nodes are either:</p>
<ul>
<li><code>Text</code> which represents <code>string</code> values. (Ex: <code>Text.raw &quot;hello&quot;</code>, <code>Text.rawf &quot;hello %s&quot; &quot;world&quot;</code>)</li>
<li><code>SelfClosingNode</code> which represent self-closing tags (Ex: <code>&lt;br /&gt;</code>).</li>
<li><code>ParentNode</code> which represent typical tags with, optionally, other tags within it (Ex: <code>&lt;div&gt;...&lt;/div&gt;</code>).</li>
</ul>
<p>The benefits of using the Falco markup module as an HTML engine include:</p>
<ul>
<li>Writing your views in plain F#, directly in your assembly.</li>
<li>Markup is compiled alongside the rest of your code, leading to improved performance and ultimately simpler deployments.</li>
</ul>
<pre><code class="language-fsharp">// Create an HTML5 document using built-in template
let doc = 
    Templates.html5 &quot;en&quot;
        [ Elem.title [] [ Text.raw &quot;Sample App&quot; ] ] // &lt;head&gt;&lt;/head&gt;
        [ Elem.h1 [] [ Text.raw &quot;Sample App&quot; ] ]    // &lt;body&gt;&lt;/body&gt;
</code></pre>
<p>Since views are plain F# they can easily be made strongly-typed:</p>
<pre><code class="language-fsharp">type Person = { FirstName : string; LastName : string }

let doc (person : Person) = 
    Elem.html [ Attr.lang &quot;en&quot; ] [
        Elem.head [] [                    
            Elem.title [] [ Text.raw &quot;Sample App&quot; ]                                                            
        ]
        Elem.body [] [                     
            Elem.main [] [
                Elem.h1 [] [ Text.raw &quot;Sample App&quot; ]
                Elem.p  [] [ Text.rawf &quot;%s %s&quot; person.First person.Last ]
            ]
        ]
    ]
</code></pre>
<p>Views can also be combined to create more complex views and share output:</p>
<pre><code class="language-fsharp">let master (title : string) (content : XmlNode list) =
    Elem.html [ Attr.lang &quot;en&quot; ] [
        Elem.head [] [                    
            Elem.title [] [ Text.raw &quot;Sample App&quot; ]                                                            
        ]
        Elem.body [] content
    ]

let divider = 
    Elem.hr [ Attr.class' &quot;divider&quot; ]

let homeView =
    [
        Elem.h1 [] [ Text.raw &quot;Homepage&quot; ]
        divider
        Elem.p  [] [ Text.raw &quot;Lorem ipsum dolor sit amet, consectetur adipiscing.&quot;]
    ]
    |&gt; master &quot;Homepage&quot; 

let aboutView =
    [
        Elem.h1 [] [ Text.raw &quot;About&quot; ]
        divider
        Elem.p  [] [ Text.raw &quot;Lorem ipsum dolor sit amet, consectetur adipiscing.&quot;]
    ]
    |&gt; master &quot;About Us&quot;
</code></pre>
<h2 id="host-builder">Host Builder</h2>
<p><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.1" title="Kestrel web server implementation in ASP.NET Core">Kestrel</a> is the web server at the heart of ASP.NET. It's performant, secure, and maintained by incredibly smart people. Getting it up and running is usually done using <code>Host.CreateDefaultBuilder(args)</code>, but it can grow verbose quickly.</p>
<p>To make things more expressive, Falco exposes an optional computation expression. Below is an example using the builder taken from the <a href="https://github.com/pimbrouwers/Falco/tree/master/samples/ConfigureHost">Configure Host</a> sample.</p>
<pre><code class="language-fsharp">[&lt;EntryPoint&gt;]
let main args = 
    webHost args {
        use_ifnot FalcoExtensions.IsDevelopment HstsBuilderExtensions.UseHsts
        use_https
        use_compression
        use_static_files

        use_if    FalcoExtensions.IsDevelopment DeveloperExceptionPageExtensions.UseDeveloperExceptionPage
        use_ifnot FalcoExtensions.IsDevelopment (FalcoExtensions.UseFalcoExceptionHandler exceptionHandler)

        endpoints [            
            get &quot;/greet/{name:alpha}&quot; 
                handleGreeting

            get &quot;/json&quot; 
                handleJson

            get &quot;/html&quot; 
                handleHtml
                
            get &quot;/&quot; 
                handlePlainText
        ]
    }
    0
</code></pre>
<h3 id="fully-customizing-the-host">Fully Customizing the Host</h3>
<p>To assume full control over configuring your <code>IHost</code> use the <code>configure</code> custom operation. It expects a function with the signature of <code>HttpEndpoint list -&gt; IWebHostBuilder -&gt; IWebHostBuilder</code> and assumes you will register and activate Falco (i.e., <code>AddFalco()</code> and <code>UseFalco(endpoints)</code>).</p>
<pre><code class="language-fsharp">[&lt;EntryPoint&gt;]
let main args = 
    let configureServices : IServiceCollection -&gt; unit = 
      fun services -&gt; services.AddFalco() |&gt; ignore
    
    let configureApp : HttpEndpoint list -&gt; IApplicationBuilder -&gt; unit =
       fun endpoints app -&gt; app.UseFalco(endpoints) |&gt; ignore

    let configureWebHost : HttpEndpoint list -&gt; IWebHostBuilder =
      fun endpoints webHost -&gt;
          webHost.ConfigureLogging(configureLogging)
                 .ConfigureServices(configureServices)
                 .Configure(configureApp endpoints)

    webHost args {
      configure configureWebHost
      endpoints []
    }
</code></pre>
<h2 id="authentication">Authentication</h2>
<p>ASP.NET Core has amazing built-in support for authentication. Review the <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/?view=aspnetcore-3.1" title="Overview of ASP.NET Core authentication">docs</a> for specific implementation details. Falco includes some authentication utilities.</p>
<blockquote>
<p>To use the authentication helpers, ensure the service has been registered (<code>AddAuthentication()</code>) with the <code>IServiceCollection</code> and activated (<code>UseAuthentication()</code>) using the <code>IApplicationBuilder</code>.</p>
</blockquote>
<p>Prevent user from accessing secure endpoint:</p>
<pre><code class="language-fsharp">open Falco.Security

let secureResourceHandler : HttpHandler =
    let handleAuth : HttpHandler = 
        &quot;hello authenticated user&quot;
        |&gt; Response.ofPlainText 

    let handleInvalid : HttpHandler =
        Response.withStatusCode 403 
        &gt;&gt; Response.ofPlainText &quot;Forbidden&quot;

    Request.ifAuthenticated handleAuth handleInvalid
</code></pre>
<p>Prevent authenticated user from accessing anonymous-only end-point:</p>
<pre><code class="language-fsharp">let anonResourceOnlyHandler : HttpHandler =
    let handleAnon : HttpHandler = 
        Response.ofPlainText &quot;hello anonymous&quot;

    let handleInvalid : HttpHandler = 
        Response.withStatusCode 403 
        &gt;&gt; Response.ofPlainText &quot;Forbidden&quot;

    Request.ifNotAuthenticated handleAnon handleInvalid
</code></pre>
<p>Allow only user's from a certain group to access endpoint&quot;</p>
<pre><code class="language-fsharp">let secureResourceHandler : HttpHandler =
    let handleAuthInRole : HttpHandler = 
        Response.ofPlainText &quot;hello admin&quot;

    let handleInvalid : HttpHandler = 
        Response.withStatusCode 403 
        &gt;&gt; Response.ofPlainText &quot;Forbidden&quot;

    let rolesAllowed = [ &quot;Admin&quot; ]

    Request.ifAuthenticatedInRole rolesAllowed handleAuthInRole handleInvalid
</code></pre>
<p>Allow only user's with a certain scope to access endpoint&quot;</p>
<pre><code class="language-fsharp">let secureResourceHandler : HttpHandler =
    let handleAuthHasScope : HttpHandler = 
        Response.ofPlainText &quot;user1, user2, user3&quot;

    let handleInvalid : HttpHandler = 
        Response.withStatusCode 403 
        &gt;&gt; Response.ofPlainText &quot;Forbidden&quot;

    let issuer = &quot;https://oauth2issuer.com&quot;
    let scope = &quot;read:users&quot;

    Request.ifAuthenticatedWithScope issuer scope handleAuthHasScope handleInvalid
</code></pre>
<p>End user session (sign out):</p>
<pre><code class="language-fsharp">let logOut : HttpHandler =         
    let authScheme = &quot;...&quot;
    let redirectTo = &quot;/login&quot;

    Response.signOutAndRedirect authScheme redirectTo
</code></pre>
<h2 id="security">Security</h2>
<p>Cross-site scripting attacks are extremely common since they are quite simple to carry out. Fortunately, protecting against them is as easy as performing them.</p>
<p>The <a href="https://docs.microsoft.com/en-us/aspnet/core/security/anti-request-forgery?view=aspnetcore-3.1" title="Prevent Cross-Site Request Forgery (XSRF/CSRF) attacks in ASP.NET Core">Microsoft.AspNetCore.Antiforgery</a> package provides the required utilities to easily protect yourself against such attacks.</p>
<p>Falco provides a few handlers via <code>Falco.Security.Xss</code>:</p>
<blockquote>
<p>To use the Xss helpers, ensure the service has been registered (<code>AddAntiforgery()</code>) with the <code>IServiceCollection</code> and activated (<code>UseAntiforgery()</code>) using the <code>IApplicationBuilder</code>.</p>
</blockquote>
<pre><code class="language-fsharp">open Falco.Markup
open Falco.Security 

let formView token =     
    Elem.html [] [
        Elem.body [] [
            Elem.form [ Attr.method &quot;post&quot; ] [
                Elem.input [ Attr.name &quot;first_name&quot; ]

                Elem.input [ Attr.name &quot;last_name&quot; ]

                // using the CSRF HTML helper
                Xss.antiforgeryInput token

                Elem.input [ Attr.type' &quot;submit&quot;; Attr.value &quot;Submit&quot; ]
            ]                                
        ]
    ]
    
// A handler that demonstrates obtaining a
// CSRF token and applying it to a view
let csrfViewHandler : HttpHandler = 
    formView
    |&gt; Response.ofHtmlCsrf
    
// A handler that demonstrates validating
// the request's CSRF token
let mapFormSecureHandler : HttpHandler =    
    let mapPerson (form : FormCollectionReader) =
        { FirstName = form.GetString &quot;first_name&quot; &quot;John&quot; // Get value or return default value
          LastName = form.GetString &quot;first_name&quot; &quot;Doe&quot; }

    let handleInvalid : HttpHandler = 
        Response.withStatusCode 400 
        &gt;&gt; Response.ofEmpty

    Request.mapFormSecure mapPerson Response.ofJson handleInvalid
</code></pre>
<h3 id="crytography">Crytography</h3>
<p>Many sites have the requirement of a secure log in and sign up (i.e. registering and maintaining a user's database). Thus, generating strong hashes and random salts is important.</p>
<p>Falco helpers are accessed by importing <code>Falco.Auth.Crypto</code>.</p>
<pre><code class="language-fsharp">open Falco.Security

// Generating salt,
// using System.Security.Cryptography.RandomNumberGenerator,
// create a random 16 byte salt and base 64 encode
let salt = Crypto.createSalt 16 

// Generate random int for iterations
let iterations = Crypto.randomInt 10000 50000

// Pbkdf2 Key derivation using HMAC algorithm with SHA256 hashing function
let password = &quot;5upe45ecure&quot;
let hashedPassword = password |&gt; Crypto.sha256 iterations 32 salt
</code></pre>
<h2 id="why-falco">Why &quot;Falco&quot;?</h2>
<p><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.1" title="Kestrel web server implementation in ASP.NET Core">Kestrel</a> has been a game changer for the .NET web stack. In the animal kingdom, &quot;Kestrel&quot; is a name given to several members of the falcon genus. Also known as &quot;Falco&quot;.</p>
<h2 id="find-a-bug">Find a bug?</h2>
<p>There's an <a href="https://github.com/pimbrouwers/Falco/issues">issue</a> for that.</p>
<h2 id="license">License</h2>
<p>Built with ♥ by <a href="https://github.com/pimbrouwers">Pim Brouwers</a> in Toronto, ON. Licensed under <a href="https://github.com/pimbrouwers/Falco/blob/master/LICENSE">Apache License 2.0</a>.</p>
</main>
  </div>
</div>
<!-- /body/footer -->
<footer class="tc ph3 pv4"> 
  <div class="f6 white-90">&copy; 2020-2021 Pim Brouwers</div>
</footer>
<!-- /body/script -->
<script src="/prism.js"></script>

</body>
</html>


